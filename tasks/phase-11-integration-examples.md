# Phase 11: Integration Examples & Complete Games\n\n## Objective\n\nDevelop comprehensive example projects and complete games that demonstrate the full capabilities of the Playdate engine while serving as learning resources, integration tests, and showcases for potential developers. These examples validate the engine's real-world usability and performance under typical game development scenarios.\n\n## Prerequisites\n\n- **Phase 1-10**: Complete engine implementation with optimization\n- Game design and development knowledge\n- Understanding of Playdate platform constraints and capabilities\n- Asset creation skills (sprites, sounds, levels)\n\n## Technical Specifications\n\n### Example Project Goals\n- **Real-world validation**: Test engine under actual game development conditions\n- **Performance demonstration**: Show engine meeting targets in complete games\n- **Learning resources**: Provide clear, documented examples for developers\n- **Platform showcase**: Highlight unique Playdate features and constraints\n- **Integration testing**: Validate all engine systems working together\n\n### Project Complexity Levels\n- **Basic Examples**: Simple demonstrations of individual features\n- **Intermediate Projects**: Games combining multiple engine systems\n- **Advanced Games**: Complex projects showcasing full engine capabilities\n- **Performance Demos**: Stress tests pushing engine to its limits\n\n## Code Structure\n\n```\nexamples/\n├── basic/                      # Simple feature demonstrations\n│   ├── hello_world/           # Minimal engine usage\n│   ├── sprite_demo/           # Basic sprite rendering\n│   ├── input_handling/        # Input system usage\n│   ├── collision_basics/      # Simple collision detection\n│   └── lua_scripting/         # Basic Lua integration\n├── intermediate/              # Multi-system games\n│   ├── platformer/            # Side-scrolling platformer\n│   ├── top_down_adventure/    # Zelda-style adventure\n│   ├── puzzle_game/           # Grid-based puzzle game\n│   ├── shooter/               # Simple shoot-em-up\n│   └── rpg_battle/            # Turn-based battle system\n├── advanced/                  # Complex showcase games\n│   ├── metroidvania/          # Large interconnected world\n│   ├── racing_game/           # Physics-heavy racing\n│   ├── strategy_game/         # RTS with many units\n│   └── sandbox_builder/       # Creative building game\n├── performance/               # Engine stress tests\n│   ├── object_stress_test/    # 10,000+ GameObjects\n│   ├── collision_benchmark/   # Massive collision detection\n│   ├── rendering_stress/      # 1000+ sprites rendering\n│   └── memory_efficiency/     # Memory usage optimization\n└── templates/                 # Project templates\n    ├── empty_project/         # Minimal starting template\n    ├── platformer_template/   # Platformer game template\n    └── lua_game_template/     # Lua-based game template\n\nassets/\n├── sprites/                   # Shared sprite assets\n├── sounds/                    # Audio assets\n├── fonts/                     # Text rendering fonts\n├── tilesets/                  # Tilemap assets\n└── animations/                # Animation sequences\n\ndocs/examples/\n├── GETTING_STARTED.md         # How to run examples\n├── GAME_DEVELOPMENT_GUIDE.md  # Complete development guide\n├── PERFORMANCE_TIPS.md        # Optimization best practices\n└── API_REFERENCE.md           # Complete API documentation\n```\n\n## Implementation Steps\n\n### Step 1: Basic Examples\n\n#### Hello World Example\n\n```c\n// examples/basic/hello_world/main.c\n#include \"playdate_engine.h\"\n\nstatic Scene* g_scene;\nstatic GameObject* g_text_object;\n\nint eventHandler(PlaydateAPI* pd, PDSystemEvent event, uint32_t arg) {\n    switch (event) {\n        case kEventInit:\n            // Initialize engine\n            engine_init(pd);\n            \n            // Create scene\n            g_scene = scene_create(\"HelloWorld\", 10);\n            \n            // Create text GameObject (would use text component in real implementation)\n            g_text_object = game_object_create(g_scene);\n            game_object_set_position(g_text_object, 200, 120);\n            \n            pd->system->setUpdateCallback(update, pd);\n            break;\n            \n        case kEventTerminate:\n            scene_destroy(g_scene);\n            break;\n            \n        default:\n            break;\n    }\n    \n    return 0;\n}\n\nstatic int update(void* userdata) {\n    PlaydateAPI* pd = (PlaydateAPI*)userdata;\n    \n    // Clear screen\n    pd->graphics->clear(kColorWhite);\n    \n    // Update scene\n    scene_update(g_scene, 1.0f / 30.0f);\n    \n    // Render scene\n    scene_render(g_scene);\n    \n    // Draw hello world text\n    pd->graphics->drawText(\"Hello, Playdate Engine!\", strlen(\"Hello, Playdate Engine!\"), \n                          kASCIIEncoding, 100, 110);\n    \n    return 1;\n}\n```\n\n#### Sprite Demo Example\n\n```c\n// examples/basic/sprite_demo/main.c\n#include \"playdate_engine.h\"\n\nstatic Scene* g_scene;\nstatic GameObject* g_player;\nstatic SpriteComponent* g_player_sprite;\n\nint eventHandler(PlaydateAPI* pd, PDSystemEvent event, uint32_t arg) {\n    switch (event) {\n        case kEventInit:\n            engine_init(pd);\n            sprite_component_set_playdate_api(pd);\n            \n            // Create scene\n            g_scene = scene_create(\"SpriteDemo\", 100);\n            \n            // Create player GameObject\n            g_player = game_object_create(g_scene);\n            game_object_set_position(g_player, 200, 120);\n            \n            // Add sprite component\n            g_player_sprite = sprite_component_create(g_player);\n            game_object_add_component(g_player, (Component*)g_player_sprite);\n            \n            // Load sprite\n            sprite_component_load_bitmap(g_player_sprite, \"assets/player.png\");\n            sprite_component_set_anchor(g_player_sprite, 0.5f, 0.5f);\n            \n            pd->system->setUpdateCallback(update, pd);\n            break;\n            \n        case kEventTerminate:\n            scene_destroy(g_scene);\n            break;\n    }\n    \n    return 0;\n}\n\nstatic int update(void* userdata) {\n    PlaydateAPI* pd = (PlaydateAPI*)userdata;\n    \n    // Handle input\n    PDButtons current, pushed, released;\n    pd->system->getButtonState(&current, &pushed, &released);\n    \n    float moveSpeed = 100.0f; // pixels per second\n    float deltaTime = 1.0f / 30.0f;\n    \n    if (current & kButtonLeft) {\n        game_object_translate(g_player, -moveSpeed * deltaTime, 0);\n        sprite_component_set_flip(g_player_sprite, kBitmapFlippedX);\n    }\n    if (current & kButtonRight) {\n        game_object_translate(g_player, moveSpeed * deltaTime, 0);\n        sprite_component_set_flip(g_player_sprite, kBitmapUnflipped);\n    }\n    if (current & kButtonUp) {\n        game_object_translate(g_player, 0, -moveSpeed * deltaTime);\n    }\n    if (current & kButtonDown) {\n        game_object_translate(g_player, 0, moveSpeed * deltaTime);\n    }\n    \n    // Update and render scene\n    pd->graphics->clear(kColorWhite);\n    scene_update(g_scene, deltaTime);\n    scene_render(g_scene);\n    \n    return 1;\n}\n```\n\n### Step 2: Intermediate Projects\n\n#### Platformer Game\n\n```c\n// examples/intermediate/platformer/game.h\n#ifndef PLATFORMER_GAME_H\n#define PLATFORMER_GAME_H\n\n#include \"playdate_engine.h\"\n\n// Game states\ntypedef enum {\n    GAME_STATE_MENU,\n    GAME_STATE_PLAYING,\n    GAME_STATE_PAUSED,\n    GAME_STATE_GAME_OVER\n} GameState;\n\n// Player controller\ntypedef struct {\n    GameObject* gameObject;\n    SpriteComponent* sprite;\n    CollisionComponent* collision;\n    \n    // Movement properties\n    float velocityX, velocityY;\n    float maxSpeed;\n    float jumpForce;\n    bool isGrounded;\n    bool isJumping;\n    \n    // Animation state\n    SpriteAnimation* idleAnimation;\n    SpriteAnimation* walkAnimation;\n    SpriteAnimation* jumpAnimation;\n    \n} PlayerController;\n\n// Level data\ntypedef struct {\n    TiledMap* tiledMap;\n    GameObject** platforms;\n    uint32_t platformCount;\n    GameObject** enemies;\n    uint32_t enemyCount;\n    GameObject** collectibles;\n    uint32_t collectibleCount;\n} Level;\n\n// Game instance\ntypedef struct {\n    PlaydateAPI* pd;\n    Scene* scene;\n    GameState state;\n    \n    PlayerController player;\n    Level currentLevel;\n    \n    // Game state\n    uint32_t score;\n    uint32_t lives;\n    float gameTime;\n    \n    // Performance monitoring\n    PerformanceMonitor* perfMonitor;\n    \n} PlatformerGame;\n\n// Game functions\nPlatformerGame* platformer_game_create(PlaydateAPI* pd);\nvoid platformer_game_destroy(PlatformerGame* game);\nvoid platformer_game_update(PlatformerGame* game, float deltaTime);\nvoid platformer_game_render(PlatformerGame* game);\nvoid platformer_game_load_level(PlatformerGame* game, const char* levelPath);\n\n// Player functions\nvoid player_controller_init(PlayerController* player, Scene* scene);\nvoid player_controller_update(PlayerController* player, float deltaTime, PDButtons buttons);\nvoid player_controller_handle_collision(PlayerController* player, const CollisionInfo* info);\n\n#endif // PLATFORMER_GAME_H\n```\n\n```c\n// examples/intermediate/platformer/player.c\n#include \"game.h\"\n#include <math.h>\n\n#define GRAVITY 980.0f          // pixels/second²\n#define MAX_FALL_SPEED 600.0f   // pixels/second\n#define JUMP_FORCE -400.0f      // pixels/second (negative = up)\n#define WALK_SPEED 150.0f       // pixels/second\n#define ACCELERATION 800.0f     // pixels/second²\n#define FRICTION 600.0f         // pixels/second²\n\nvoid player_controller_init(PlayerController* player, Scene* scene) {\n    // Create player GameObject\n    player->gameObject = game_object_create(scene);\n    game_object_set_position(player->gameObject, 100, 200);\n    \n    // Add sprite component\n    player->sprite = sprite_component_create(player->gameObject);\n    game_object_add_component(player->gameObject, (Component*)player->sprite);\n    \n    // Load player sprite and animations\n    sprite_component_load_bitmap(player->sprite, \"assets/player_spritesheet.png\");\n    sprite_component_set_anchor(player->sprite, 0.5f, 1.0f); // Bottom-center anchor\n    \n    // Add collision component\n    player->collision = collision_component_create(player->gameObject);\n    game_object_add_component(player->gameObject, (Component*)player->collision);\n    collision_component_set_bounds(player->collision, 16, 24);\n    collision_component_set_type(player->collision, COLLISION_TYPE_DYNAMIC);\n    collision_component_set_collision_enter_callback(player->collision, \n        (CollisionCallback)player_controller_handle_collision);\n    \n    // Initialize movement properties\n    player->velocityX = 0.0f;\n    player->velocityY = 0.0f;\n    player->maxSpeed = WALK_SPEED;\n    player->jumpForce = JUMP_FORCE;\n    player->isGrounded = false;\n    player->isJumping = false;\n    \n    // Load animations (simplified - would load from aseprite files)\n    // player->idleAnimation = load_animation(\"player_idle\");\n    // player->walkAnimation = load_animation(\"player_walk\");\n    // player->jumpAnimation = load_animation(\"player_jump\");\n}\n\nvoid player_controller_update(PlayerController* player, float deltaTime, PDButtons buttons) {\n    // Handle horizontal movement\n    float targetVelocityX = 0.0f;\n    \n    if (buttons & kButtonLeft) {\n        targetVelocityX = -player->maxSpeed;\n        sprite_component_set_flip(player->sprite, kBitmapFlippedX);\n    } else if (buttons & kButtonRight) {\n        targetVelocityX = player->maxSpeed;\n        sprite_component_set_flip(player->sprite, kBitmapUnflipped);\n    }\n    \n    // Apply acceleration/friction\n    if (targetVelocityX != 0) {\n        // Accelerate towards target velocity\n        if (player->velocityX < targetVelocityX) {\n            player->velocityX = fminf(player->velocityX + ACCELERATION * deltaTime, targetVelocityX);\n        } else if (player->velocityX > targetVelocityX) {\n            player->velocityX = fmaxf(player->velocityX - ACCELERATION * deltaTime, targetVelocityX);\n        }\n    } else {\n        // Apply friction when no input\n        if (player->velocityX > 0) {\n            player->velocityX = fmaxf(0, player->velocityX - FRICTION * deltaTime);\n        } else if (player->velocityX < 0) {\n            player->velocityX = fminf(0, player->velocityX + FRICTION * deltaTime);\n        }\n    }\n    \n    // Handle jumping\n    if ((buttons & kButtonA) && player->isGrounded && !player->isJumping) {\n        player->velocityY = player->jumpForce;\n        player->isJumping = true;\n        player->isGrounded = false;\n    }\n    \n    // Apply gravity\n    if (!player->isGrounded) {\n        player->velocityY += GRAVITY * deltaTime;\n        player->velocityY = fminf(player->velocityY, MAX_FALL_SPEED);\n    }\n    \n    // Update position\n    game_object_translate(player->gameObject, \n                         player->velocityX * deltaTime, \n                         player->velocityY * deltaTime);\n    \n    // Update animation based on state\n    if (!player->isGrounded) {\n        // sprite_component_play_animation(player->sprite, player->jumpAnimation);\n    } else if (fabsf(player->velocityX) > 0.1f) {\n        // sprite_component_play_animation(player->sprite, player->walkAnimation);\n    } else {\n        // sprite_component_play_animation(player->sprite, player->idleAnimation);\n    }\n    \n    // Reset grounded state (will be set by collision detection)\n    player->isGrounded = false;\n}\n\nvoid player_controller_handle_collision(PlayerController* player, const CollisionInfo* info) {\n    // Handle collision with platforms\n    if (info->other && game_object_has_component(info->other, COMPONENT_TYPE_COLLISION)) {\n        CollisionComponent* otherCollision = (CollisionComponent*)game_object_get_component(info->other, COMPONENT_TYPE_COLLISION);\n        \n        // Check if it's a platform\n        if (collision_component_get_layer(otherCollision) == LAYER_PLATFORMS) {\n            // Landing on top of platform\n            if (info->normalY < -0.5f && player->velocityY > 0) {\n                player->velocityY = 0;\n                player->isGrounded = true;\n                player->isJumping = false;\n                \n                // Adjust position to sit on platform\n                game_object_translate(player->gameObject, 0, info->penetrationY);\n            }\n            // Hitting platform from below\n            else if (info->normalY > 0.5f && player->velocityY < 0) {\n                player->velocityY = 0;\n                game_object_translate(player->gameObject, 0, info->penetrationY);\n            }\n            // Hitting platform from side\n            else if (fabsf(info->normalX) > 0.5f) {\n                player->velocityX = 0;\n                game_object_translate(player->gameObject, info->penetrationX, 0);\n            }\n        }\n    }\n}\n```\n\n### Step 3: Advanced Showcase Games\n\n#### Strategy Game with Many Units\n\n```c\n// examples/advanced/strategy_game/game.h\n#ifndef STRATEGY_GAME_H\n#define STRATEGY_GAME_H\n\n#include \"playdate_engine.h\"\n\n#define MAX_UNITS 1000\n#define MAX_BUILDINGS 200\n#define MAP_WIDTH 64\n#define MAP_HEIGHT 64\n\n// Unit types\ntypedef enum {\n    UNIT_TYPE_WORKER,\n    UNIT_TYPE_SOLDIER,\n    UNIT_TYPE_ARCHER,\n    UNIT_TYPE_CAVALRY\n} UnitType;\n\n// Unit AI states\ntypedef enum {\n    AI_STATE_IDLE,\n    AI_STATE_MOVING,\n    AI_STATE_ATTACKING,\n    AI_STATE_GATHERING,\n    AI_STATE_BUILDING\n} AIState;\n\n// Game unit\ntypedef struct {\n    GameObject* gameObject;\n    SpriteComponent* sprite;\n    CollisionComponent* collision;\n    \n    UnitType type;\n    uint32_t playerId;\n    \n    // Stats\n    float health;\n    float maxHealth;\n    float damage;\n    float speed;\n    float range;\n    \n    // AI\n    AIState aiState;\n    GameObject* target;\n    float targetX, targetY;\n    \n    // Path finding\n    uint32_t* path;\n    uint32_t pathLength;\n    uint32_t pathIndex;\n    \n} Unit;\n\n// Game instance\ntypedef struct {\n    PlaydateAPI* pd;\n    Scene* scene;\n    \n    // Units and buildings\n    Unit units[MAX_UNITS];\n    uint32_t unitCount;\n    \n    // Map and pathfinding\n    uint8_t map[MAP_WIDTH][MAP_HEIGHT]; // 0 = passable, 1 = blocked\n    \n    // Spatial optimization\n    SpatialGrid* spatialGrid;\n    \n    // Performance monitoring\n    uint32_t unitsUpdatedThisFrame;\n    float aiUpdateTime;\n    float pathfindingTime;\n    \n} StrategyGame;\n\n// Game functions\nStrategyGame* strategy_game_create(PlaydateAPI* pd);\nvoid strategy_game_destroy(StrategyGame* game);\nvoid strategy_game_update(StrategyGame* game, float deltaTime);\nvoid strategy_game_render(StrategyGame* game);\n\n// Unit management\nUnit* strategy_game_create_unit(StrategyGame* game, UnitType type, float x, float y, uint32_t playerId);\nvoid strategy_game_update_units(StrategyGame* game, float deltaTime);\nvoid strategy_game_update_unit_ai(StrategyGame* game, Unit* unit, float deltaTime);\n\n// Pathfinding\nbool strategy_game_find_path(StrategyGame* game, float startX, float startY, float endX, float endY,\n                           uint32_t** path, uint32_t* pathLength);\n\n#endif // STRATEGY_GAME_H\n```\n\n### Step 4: Performance Stress Tests\n\n#### Object Stress Test\n\n```c\n// examples/performance/object_stress_test/main.c\n#include \"playdate_engine.h\"\n#include \"profiler.h\"\n#include \"performance_monitor.h\"\n\n#define TARGET_OBJECT_COUNT 10000\n#define SPAWN_RATE 100 // objects per second\n\nstatic Scene* g_scene;\nstatic GameObject** g_objects;\nstatic uint32_t g_object_count;\nstatic float g_spawn_timer;\nstatic PerformanceMonitor* g_perf_monitor;\n\nint eventHandler(PlaydateAPI* pd, PDSystemEvent event, uint32_t arg) {\n    switch (event) {\n        case kEventInit:\n            // Initialize engine with profiling\n            engine_init(pd);\n            profiler_init();\n            profiler_enable(true);\n            \n            // Initialize performance monitoring\n            g_perf_monitor = performance_monitor_create();\n            performance_monitor_enable(g_perf_monitor, true);\n            \n            // Create scene\n            g_scene = scene_create(\"StressTest\", TARGET_OBJECT_COUNT + 1000);\n            \n            // Allocate object array\n            g_objects = malloc(TARGET_OBJECT_COUNT * sizeof(GameObject*));\n            g_object_count = 0;\n            g_spawn_timer = 0;\n            \n            pd->system->setUpdateCallback(update, pd);\n            break;\n            \n        case kEventTerminate:\n            // Print performance report\n            profiler_print_report();\n            performance_monitor_print_report(g_perf_monitor);\n            \n            // Cleanup\n            free(g_objects);\n            performance_monitor_destroy(g_perf_monitor);\n            scene_destroy(g_scene);\n            profiler_shutdown();\n            break;\n    }\n    \n    return 0;\n}\n\nstatic int update(void* userdata) {\n    PROFILE_FUNCTION();\n    \n    PlaydateAPI* pd = (PlaydateAPI*)userdata;\n    float deltaTime = 1.0f / 30.0f;\n    \n    // Spawn new objects\n    g_spawn_timer += deltaTime;\n    if (g_spawn_timer >= 1.0f / SPAWN_RATE && g_object_count < TARGET_OBJECT_COUNT) {\n        PROFILE_SCOPE(\"Object Creation\");\n        \n        GameObject* obj = game_object_create(g_scene);\n        if (obj) {\n            // Random position\n            float x = (rand() % 400) + 10;\n            float y = (rand() % 240) + 10;\n            game_object_set_position(obj, x, y);\n            \n            // Add sprite component\n            SpriteComponent* sprite = sprite_component_create(obj);\n            game_object_add_component(obj, (Component*)sprite);\n            \n            g_objects[g_object_count] = obj;\n            g_object_count++;\n        }\n        \n        g_spawn_timer = 0;\n    }\n    \n    // Update all objects\n    {\n        PROFILE_SCOPE(\"Object Updates\");\n        \n        // Make objects move in simple patterns\n        for (uint32_t i = 0; i < g_object_count; i++) {\n            GameObject* obj = g_objects[i];\n            if (obj) {\n                float x, y;\n                game_object_get_position(obj, &x, &y);\n                \n                // Simple circular motion\n                float speed = 50.0f;\n                float angle = (float)i * 0.1f + g_spawn_timer;\n                x += cosf(angle) * speed * deltaTime;\n                y += sinf(angle) * speed * deltaTime;\n                \n                // Wrap around screen\n                if (x < 0) x = 400;\n                if (x > 400) x = 0;\n                if (y < 0) y = 240;\n                if (y > 240) y = 0;\n                \n                game_object_set_position(obj, x, y);\n            }\n        }\n    }\n    \n    // Update scene\n    {\n        PROFILE_SCOPE(\"Scene Update\");\n        scene_update(g_scene, deltaTime);\n    }\n    \n    // Render\n    {\n        PROFILE_SCOPE(\"Rendering\");\n        pd->graphics->clear(kColorWhite);\n        scene_render(g_scene);\n        \n        // Draw performance info\n        char info[128];\n        snprintf(info, sizeof(info), \"Objects: %u/%u FPS: %.1f\", \n                g_object_count, TARGET_OBJECT_COUNT, profiler_get_fps());\n        pd->graphics->drawText(info, strlen(info), kASCIIEncoding, 10, 10);\n    }\n    \n    // Update performance monitor\n    performance_monitor_update(g_perf_monitor, deltaTime);\n    \n    return 1;\n}\n```\n\n### Step 5: Lua Scripted Games\n\n#### Lua Game Template\n\n```lua\n-- examples/templates/lua_game_template/main.lua\nimport \"playdate_engine_lua\"\n\n-- Game state\nlocal gameState = {\n    scene = nil,\n    player = nil,\n    enemies = {},\n    score = 0,\n    gameTime = 0\n}\n\n-- Initialize game\nfunction gameState.init()\n    print(\"Initializing Lua game...\")\n    \n    -- Create scene\n    gameState.scene = Scene.new(\"LuaGame\", 1000)\n    \n    -- Create player\n    gameState.player = GameObject.new()\n    gameState.player:setPosition(200, 120)\n    \n    -- Add sprite component\n    local sprite = gameState.player:addComponent(\"Sprite\")\n    sprite:loadImage(\"assets/player.png\")\n    \n    -- Add collision component\n    local collision = gameState.player:addComponent(\"Collision\")\n    collision:setBounds(16, 16)\n    \n    -- Spawn some enemies\n    gameState.spawnEnemies(5)\nend\n\n-- Spawn enemies\nfunction gameState.spawnEnemies(count)\n    for i = 1, count do\n        local enemy = GameObject.new()\n        enemy:setPosition(math.random(50, 350), math.random(50, 190))\n        \n        local sprite = enemy:addComponent(\"Sprite\")\n        sprite:loadImage(\"assets/enemy.png\")\n        \n        local collision = enemy:addComponent(\"Collision\")\n        collision:setBounds(12, 12)\n        collision:setLayer(2) -- Enemy layer\n        \n        table.insert(gameState.enemies, enemy)\n    end\nend\n\n-- Update game\nfunction gameState.update(dt)\n    gameState.gameTime = gameState.gameTime + dt\n    \n    -- Handle player input\n    local moveSpeed = 120 -- pixels per second\n    \n    if playdate.buttonIsPressed(playdate.kButtonLeft) then\n        gameState.player:translate(-moveSpeed * dt, 0)\n    end\n    if playdate.buttonIsPressed(playdate.kButtonRight) then\n        gameState.player:translate(moveSpeed * dt, 0)\n    end\n    if playdate.buttonIsPressed(playdate.kButtonUp) then\n        gameState.player:translate(0, -moveSpeed * dt)\n    end\n    if playdate.buttonIsPressed(playdate.kButtonDown) then\n        gameState.player:translate(0, moveSpeed * dt)\n    end\n    \n    -- Update enemies (simple AI)\n    for i, enemy in ipairs(gameState.enemies) do\n        if enemy then\n            -- Simple chase AI\n            local playerX, playerY = gameState.player:getPosition()\n            local enemyX, enemyY = enemy:getPosition()\n            \n            local dx = playerX - enemyX\n            local dy = playerY - enemyY\n            local distance = math.sqrt(dx * dx + dy * dy)\n            \n            if distance > 1 then\n                local speed = 60 * dt\n                enemy:translate((dx / distance) * speed, (dy / distance) * speed)\n            end\n        end\n    end\n    \n    -- Update scene\n    gameState.scene:update(dt)\nend\n\n-- Render game\nfunction gameState.render()\n    playdate.graphics.clear(playdate.graphics.kColorWhite)\n    \n    -- Render scene\n    gameState.scene:render()\n    \n    -- Draw UI\n    playdate.graphics.drawText(\"Score: \" .. gameState.score, 10, 10)\n    playdate.graphics.drawText(\"Time: \" .. string.format(\"%.1f\", gameState.gameTime), 10, 30)\n    playdate.graphics.drawText(\"Enemies: \" .. #gameState.enemies, 10, 50)\nend\n\n-- Playdate callbacks\nfunction playdate.update()\n    gameState.update(1/30)\nend\n\nfunction playdate.draw()\n    gameState.render()\nend\n\n-- Initialize game\ngameState.init()\n```\n\n## Documentation and Guides\n\n### Complete Development Guide\n\n```markdown\n# Game Development Guide\n\n## Getting Started\n\n### Setting Up Your Development Environment\n\n1. Install the Playdate SDK\n2. Clone the Playdate Engine repository\n3. Build the engine using the provided scripts\n4. Set up your IDE with engine headers\n\n### Your First Game\n\n1. Start with the empty_project template\n2. Initialize the engine in your main function\n3. Create a scene and GameObjects\n4. Add components for functionality\n5. Handle input and update logic\n6. Render your game world\n\n### Engine Architecture Overview\n\n- **GameObjects**: Containers for game entities\n- **Components**: Modular functionality (Transform, Sprite, Collision)\n- **Scenes**: Organize and manage GameObjects\n- **Systems**: Update and render components efficiently\n\n### Performance Best Practices\n\n1. **Object Pooling**: Reuse GameObjects instead of creating/destroying\n2. **Batch Operations**: Group similar operations together\n3. **Spatial Partitioning**: Use collision layers and spatial queries\n4. **Memory Management**: Monitor allocations and avoid leaks\n5. **Profiling**: Use built-in profiler to identify bottlenecks\n\n### Common Patterns\n\n#### Player Controller\n```c\n// Handle input and movement\nvoid update_player(PlayerController* player, float deltaTime, PDButtons buttons)\n{\n    // Input handling\n    if (buttons & kButtonLeft) {\n        player->velocityX = -player->speed;\n    }\n    // ... more input handling\n    \n    // Physics update\n    player->velocityY += gravity * deltaTime;\n    \n    // Update position\n    game_object_translate(player->gameObject, \n                         player->velocityX * deltaTime,\n                         player->velocityY * deltaTime);\n}\n```\n\n#### Collision Handling\n```c\n// Collision callback\nvoid on_collision(CollisionComponent* self, const CollisionInfo* info)\n{\n    GameObject* other = info->other;\n    \n    if (game_object_has_component(other, COMPONENT_TYPE_ENEMY)) {\n        // Handle collision with enemy\n        player_take_damage(self->gameObject);\n    }\n}\n```\n\n#### Game State Management\n```c\ntypedef enum {\n    GAME_STATE_MENU,\n    GAME_STATE_PLAYING,\n    GAME_STATE_PAUSED,\n    GAME_STATE_GAME_OVER\n} GameState;\n\nvoid update_game(Game* game, float deltaTime)\n{\n    switch (game->state) {\n        case GAME_STATE_PLAYING:\n            update_gameplay(game, deltaTime);\n            break;\n        case GAME_STATE_PAUSED:\n            update_pause_menu(game, deltaTime);\n            break;\n        // ... other states\n    }\n}\n```\n\n## Advanced Topics\n\n### Custom Components\n\nCreate your own components by extending the base Component structure:\n\n```c\ntypedef struct {\n    Component base;\n    // Your custom data\n    float customProperty;\n} CustomComponent;\n```\n\n### Lua Scripting\n\nUse Lua for rapid prototyping and gameplay logic:\n\n```lua\n-- Define behavior in Lua\nfunction updateEnemy(enemy, deltaTime)\n    -- AI logic here\nend\n```\n\n### Asset Pipeline\n\n- Use Aseprite for sprites and animations\n- Use Tiled for level design\n- Organize assets in logical folder structures\n- Consider memory constraints (16MB total)\n\n### Debugging and Profiling\n\n- Use the built-in profiler to identify performance bottlenecks\n- Monitor memory usage with the memory tracker\n- Enable debug rendering for collision bounds\n- Use performance monitor for real-time analysis\n```\n\n## Testing and Validation\n\n### Example Project Tests\n\n```c\n// tests/examples/test_examples.c\n#include \"playdate_engine.h\"\n#include <assert.h>\n#include <stdio.h>\n\nvoid test_hello_world_example(void) {\n    printf(\"Testing Hello World example...\\n\");\n    \n    // Initialize engine\n    engine_init(NULL);\n    \n    // Create basic scene\n    Scene* scene = scene_create(\"Test\", 10);\n    assert(scene != NULL);\n    \n    // Create GameObject\n    GameObject* obj = game_object_create(scene);\n    assert(obj != NULL);\n    \n    // Basic functionality test\n    game_object_set_position(obj, 100, 100);\n    float x, y;\n    game_object_get_position(obj, &x, &y);\n    assert(x == 100.0f && y == 100.0f);\n    \n    // Cleanup\n    scene_destroy(scene);\n    \n    printf(\"✓ Hello World example test passed\\n\");\n}\n\nvoid test_sprite_demo_example(void) {\n    printf(\"Testing Sprite Demo example...\\n\");\n    \n    component_registry_init();\n    sprite_component_register();\n    \n    Scene* scene = scene_create(\"SpriteTest\", 10);\n    GameObject* obj = game_object_create(scene);\n    \n    // Add sprite component\n    SpriteComponent* sprite = sprite_component_create(obj);\n    assert(sprite != NULL);\n    \n    GameObjectResult result = game_object_add_component(obj, (Component*)sprite);\n    assert(result == GAMEOBJECT_OK);\n    \n    // Test sprite properties\n    sprite_component_set_anchor(sprite, 0.5f, 0.5f);\n    float anchorX, anchorY;\n    sprite_component_get_anchor(sprite, &anchorX, &anchorY);\n    assert(anchorX == 0.5f && anchorY == 0.5f);\n    \n    // Cleanup\n    scene_destroy(scene);\n    component_registry_shutdown();\n    \n    printf(\"✓ Sprite Demo example test passed\\n\");\n}\n\nvoid test_platformer_performance(void) {\n    printf(\"Testing Platformer performance...\\n\");\n    \n    // This would test the platformer example under load\n    // to ensure it meets performance targets\n    \n    profiler_init();\n    profiler_enable(true);\n    \n    // Run platformer simulation\n    // ... (simplified for brevity)\n    \n    // Verify performance\n    float avgFrameTime = profiler_get_average_frame_time();\n    assert(avgFrameTime < 33.0f); // 30 FPS target\n    \n    profiler_shutdown();\n    \n    printf(\"✓ Platformer performance test passed\\n\");\n}\n```\n\n## Integration Points\n\n### All Engine Systems\n- Examples demonstrate integration of all engine components\n- Real-world validation of API design and usability\n- Performance testing under game development scenarios\n- Documentation of best practices and common patterns\n\n## Success Criteria\n\n### Functional Requirements\n- [ ] Complete set of examples from basic to advanced\n- [ ] All examples run smoothly on Playdate hardware\n- [ ] Comprehensive documentation and tutorials\n- [ ] Project templates for rapid development\n- [ ] Performance demonstrations meeting targets\n\n### Educational Value\n- [ ] Clear progression from simple to complex examples\n- [ ] Well-commented code with explanations\n- [ ] Best practices demonstrated throughout\n- [ ] Common pitfalls and solutions documented\n- [ ] Asset creation and optimization guidance\n\n### Quality Requirements\n- [ ] All examples tested and validated\n- [ ] Performance benchmarks for complex games\n- [ ] Cross-platform compatibility verified\n- [ ] Complete API coverage in examples\n\n## Next Steps\n\nUpon completion of this phase:\n1. Verify all examples run correctly on target hardware\n2. Validate performance targets in real game scenarios\n3. Gather feedback from developers using examples\n4. Document lessons learned and update engine accordingly\n5. Prepare for engine release with comprehensive example suite\n\nThis phase validates the engine's real-world applicability while providing developers with the resources needed to create compelling games efficiently.